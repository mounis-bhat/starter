package api

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	scalar "github.com/MarceloPetrucio/go-scalar-api-reference"
	_ "github.com/mounis-bhat/starter/docs"
)

const scalarScriptURL = "https://cdn.jsdelivr.net/npm/@scalar/api-reference"

var scalarScriptMu sync.Mutex
var scalarScript []byte

// handleOpenAPISpec serves the OpenAPI specification
func handleOpenAPISpec(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")

	// Prefer the swagger.json generated by swag
	if _, err := os.Stat("docs/swagger.json"); err == nil {
		http.ServeFile(w, r, "docs/swagger.json")
		return
	}
	http.ServeFile(w, r, "docs/openapi.json")
}

// handleScalarDocs serves the Scalar API documentation UI
func handleScalarDocs(w http.ResponseWriter, r *http.Request) {
	specURL := buildSpecURL(r)
	htmlContent, err := scalar.ApiReferenceHTML(&scalar.Options{
		SpecURL: specURL,
		CustomOptions: scalar.CustomOptions{
			PageTitle: "API Reference",
		},
		CDN: "/api/docs/scalar.js",
	})
	if err != nil {
		http.Error(w, "Failed to render API reference", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Security-Policy", docsCSP)
	w.Header().Set("Content-Type", "text/html")
	_, _ = w.Write([]byte(htmlContent))
}

func buildSpecURL(r *http.Request) string {
	scheme := "http"
	if r.TLS != nil {
		scheme = "https"
	}
	if forwarded := r.Header.Get("X-Forwarded-Proto"); forwarded != "" {
		if comma := strings.Index(forwarded, ","); comma >= 0 {
			forwarded = forwarded[:comma]
		}
		scheme = strings.TrimSpace(forwarded)
	}

	host := r.Host
	if host == "" {
		host = "localhost"
	}

	return fmt.Sprintf("%s://%s/api/openapi.json", scheme, host)
}

func handleScalarScript(w http.ResponseWriter, r *http.Request) {
	scalarScriptMu.Lock()
	script := scalarScript
	scalarScriptMu.Unlock()

	if script == nil {
		fetched, err := fetchScalarScript()
		if err != nil {
			http.Error(w, "Failed to load Scalar script", http.StatusBadGateway)
			return
		}
		scalarScriptMu.Lock()
		if scalarScript == nil {
			scalarScript = fetched
		}
		script = scalarScript
		scalarScriptMu.Unlock()
	}

	w.Header().Set("Content-Type", "application/javascript")
	_, _ = w.Write(script)
}

func fetchScalarScript() ([]byte, error) {
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Get(scalarScriptURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("scalar script fetch failed: %s", resp.Status)
	}

	return io.ReadAll(resp.Body)
}

const docsCSP = "default-src 'self'; base-uri 'self'; frame-ancestors 'none'; object-src 'none'; form-action 'self'; img-src 'self' data: https:; style-src 'self' 'unsafe-inline'; script-src 'self'; connect-src 'self'; font-src 'self' data:; media-src 'self'; manifest-src 'self'; worker-src 'self'; frame-src 'none'"
