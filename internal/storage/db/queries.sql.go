// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUserSessions = `-- name: CountUserSessions :one
SELECT COUNT(*) FROM sessions WHERE user_id = $1
`

func (q *Queries) CountUserSessions(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserSessions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :exec

INSERT INTO audit_logs (user_id, event_type, ip_address, user_agent, metadata)
VALUES ($1, $2, $3, $4, $5)
`

type CreateAuditLogParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	EventType string      `json:"event_type"`
	IpAddress *netip.Addr `json:"ip_address"`
	UserAgent pgtype.Text `json:"user_agent"`
	Metadata  []byte      `json:"metadata"`
}

// Audit logs
func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) error {
	_, err := q.db.Exec(ctx, createAuditLog,
		arg.UserID,
		arg.EventType,
		arg.IpAddress,
		arg.UserAgent,
		arg.Metadata,
	)
	return err
}

const createSession = `-- name: CreateSession :one

INSERT INTO sessions (user_id, token_hash, expires_at, ip_address, user_agent)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, token_hash, expires_at, last_active_at, ip_address, user_agent, created_at
`

type CreateSessionParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	IpAddress *netip.Addr        `json:"ip_address"`
	UserAgent pgtype.Text        `json:"user_agent"`
}

// Sessions
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.TokenHash,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.LastActiveAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (email, email_verified, name, picture, password_hash, provider, google_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, email, email_verified, name, picture, password_hash, provider, google_id, email_verification_token_hash, email_verification_expires_at, failed_login_attempts, locked_until, created_at, updated_at
`

type CreateUserParams struct {
	Email         string      `json:"email"`
	EmailVerified bool        `json:"email_verified"`
	Name          string      `json:"name"`
	Picture       pgtype.Text `json:"picture"`
	PasswordHash  pgtype.Text `json:"password_hash"`
	Provider      string      `json:"provider"`
	GoogleID      pgtype.Text `json:"google_id"`
}

// Users
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.EmailVerified,
		arg.Name,
		arg.Picture,
		arg.PasswordHash,
		arg.Provider,
		arg.GoogleID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
		&i.Picture,
		&i.PasswordHash,
		&i.Provider,
		&i.GoogleID,
		&i.EmailVerificationTokenHash,
		&i.EmailVerificationExpiresAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSession, id)
	return err
}

const deleteSessionByTokenHash = `-- name: DeleteSessionByTokenHash :exec
DELETE FROM sessions WHERE token_hash = $1
`

func (q *Queries) DeleteSessionByTokenHash(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, deleteSessionByTokenHash, tokenHash)
	return err
}

const deleteUserSessions = `-- name: DeleteUserSessions :exec
DELETE FROM sessions WHERE user_id = $1
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserSessions, userID)
	return err
}

const getOldestUserSession = `-- name: GetOldestUserSession :one
SELECT id, user_id, token_hash, expires_at, last_active_at, ip_address, user_agent, created_at FROM sessions
WHERE user_id = $1
ORDER BY created_at ASC
LIMIT 1
`

func (q *Queries) GetOldestUserSession(ctx context.Context, userID pgtype.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, getOldestUserSession, userID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.LastActiveAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByTokenHash = `-- name: GetSessionByTokenHash :one
SELECT s.id, s.user_id, s.token_hash, s.expires_at, s.last_active_at, s.ip_address, s.user_agent, s.created_at, u.id AS "user.id", u.email AS "user.email", u.email_verified AS "user.email_verified",
       u.name AS "user.name", u.picture AS "user.picture", u.provider AS "user.provider"
FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.token_hash = $1 AND s.expires_at > NOW()
`

type GetSessionByTokenHashRow struct {
	ID                pgtype.UUID        `json:"id"`
	UserID            pgtype.UUID        `json:"user_id"`
	TokenHash         string             `json:"token_hash"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	LastActiveAt      pgtype.Timestamptz `json:"last_active_at"`
	IpAddress         *netip.Addr        `json:"ip_address"`
	UserAgent         pgtype.Text        `json:"user_agent"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UserID_2          pgtype.UUID        `json:"user.id_2"`
	UserEmail         string             `json:"user.email"`
	UserEmailVerified bool               `json:"user.email_verified"`
	UserName          string             `json:"user.name"`
	UserPicture       pgtype.Text        `json:"user.picture"`
	UserProvider      string             `json:"user.provider"`
}

func (q *Queries) GetSessionByTokenHash(ctx context.Context, tokenHash string) (GetSessionByTokenHashRow, error) {
	row := q.db.QueryRow(ctx, getSessionByTokenHash, tokenHash)
	var i GetSessionByTokenHashRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.LastActiveAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UserID_2,
		&i.UserEmail,
		&i.UserEmailVerified,
		&i.UserName,
		&i.UserPicture,
		&i.UserProvider,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, email_verified, name, picture, password_hash, provider, google_id, email_verification_token_hash, email_verification_expires_at, failed_login_attempts, locked_until, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
		&i.Picture,
		&i.PasswordHash,
		&i.Provider,
		&i.GoogleID,
		&i.EmailVerificationTokenHash,
		&i.EmailVerificationExpiresAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByGoogleID = `-- name: GetUserByGoogleID :one
SELECT id, email, email_verified, name, picture, password_hash, provider, google_id, email_verification_token_hash, email_verification_expires_at, failed_login_attempts, locked_until, created_at, updated_at FROM users WHERE google_id = $1
`

func (q *Queries) GetUserByGoogleID(ctx context.Context, googleID pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByGoogleID, googleID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
		&i.Picture,
		&i.PasswordHash,
		&i.Provider,
		&i.GoogleID,
		&i.EmailVerificationTokenHash,
		&i.EmailVerificationExpiresAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, email_verified, name, picture, password_hash, provider, google_id, email_verification_token_hash, email_verification_expires_at, failed_login_attempts, locked_until, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
		&i.Picture,
		&i.PasswordHash,
		&i.Provider,
		&i.GoogleID,
		&i.EmailVerificationTokenHash,
		&i.EmailVerificationExpiresAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementFailedLoginAttempts = `-- name: IncrementFailedLoginAttempts :one
UPDATE users
SET failed_login_attempts = failed_login_attempts + 1
WHERE id = $1
RETURNING id, email, email_verified, name, picture, password_hash, provider, google_id, email_verification_token_hash, email_verification_expires_at, failed_login_attempts, locked_until, created_at, updated_at
`

func (q *Queries) IncrementFailedLoginAttempts(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, incrementFailedLoginAttempts, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
		&i.Picture,
		&i.PasswordHash,
		&i.Provider,
		&i.GoogleID,
		&i.EmailVerificationTokenHash,
		&i.EmailVerificationExpiresAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const lockUser = `-- name: LockUser :exec
UPDATE users
SET locked_until = $2
WHERE id = $1
`

type LockUserParams struct {
	ID          pgtype.UUID        `json:"id"`
	LockedUntil pgtype.Timestamptz `json:"locked_until"`
}

func (q *Queries) LockUser(ctx context.Context, arg LockUserParams) error {
	_, err := q.db.Exec(ctx, lockUser, arg.ID, arg.LockedUntil)
	return err
}

const purgeAuditLogsBefore = `-- name: PurgeAuditLogsBefore :one
WITH deleted AS (
    DELETE FROM audit_logs
    WHERE created_at < $1
    RETURNING 1
)
SELECT COUNT(*) FROM deleted
`

func (q *Queries) PurgeAuditLogsBefore(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, purgeAuditLogsBefore, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const resetFailedLoginAttempts = `-- name: ResetFailedLoginAttempts :exec
UPDATE users
SET failed_login_attempts = 0
WHERE id = $1
`

func (q *Queries) ResetFailedLoginAttempts(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, resetFailedLoginAttempts, id)
	return err
}

const unlockUser = `-- name: UnlockUser :exec
UPDATE users
SET locked_until = NULL, failed_login_attempts = 0
WHERE id = $1
`

func (q *Queries) UnlockUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, unlockUser, id)
	return err
}

const updateSessionLastActive = `-- name: UpdateSessionLastActive :exec
UPDATE sessions
SET last_active_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateSessionLastActive(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateSessionLastActive, id)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET name = COALESCE($1, name),
    picture = COALESCE($2, picture),
    email_verified = COALESCE($3, email_verified),
    password_hash = COALESCE($4, password_hash)
WHERE id = $5
RETURNING id, email, email_verified, name, picture, password_hash, provider, google_id, email_verification_token_hash, email_verification_expires_at, failed_login_attempts, locked_until, created_at, updated_at
`

type UpdateUserParams struct {
	Name          pgtype.Text `json:"name"`
	Picture       pgtype.Text `json:"picture"`
	EmailVerified pgtype.Bool `json:"email_verified"`
	PasswordHash  pgtype.Text `json:"password_hash"`
	ID            pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.Name,
		arg.Picture,
		arg.EmailVerified,
		arg.PasswordHash,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
		&i.Picture,
		&i.PasswordHash,
		&i.Provider,
		&i.GoogleID,
		&i.EmailVerificationTokenHash,
		&i.EmailVerificationExpiresAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setEmailVerificationToken = `-- name: SetEmailVerificationToken :exec
UPDATE users
SET email_verification_token_hash = $2,
    email_verification_expires_at = $3
WHERE id = $1
`

type SetEmailVerificationTokenParams struct {
	ID                         pgtype.UUID        `json:"id"`
	EmailVerificationTokenHash string             `json:"email_verification_token_hash"`
	EmailVerificationExpiresAt pgtype.Timestamptz `json:"email_verification_expires_at"`
}

func (q *Queries) SetEmailVerificationToken(ctx context.Context, arg SetEmailVerificationTokenParams) error {
	_, err := q.db.Exec(ctx, setEmailVerificationToken, arg.ID, arg.EmailVerificationTokenHash, arg.EmailVerificationExpiresAt)
	return err
}

const getUserByEmailVerificationTokenHash = `-- name: GetUserByEmailVerificationTokenHash :one
SELECT id, email, email_verified, name, picture, password_hash, provider, google_id, email_verification_token_hash, email_verification_expires_at, failed_login_attempts, locked_until, created_at, updated_at
FROM users
WHERE email_verification_token_hash = $1
`

func (q *Queries) GetUserByEmailVerificationTokenHash(ctx context.Context, emailVerificationTokenHash string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmailVerificationTokenHash, emailVerificationTokenHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
		&i.Picture,
		&i.PasswordHash,
		&i.Provider,
		&i.GoogleID,
		&i.EmailVerificationTokenHash,
		&i.EmailVerificationExpiresAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const verifyUserEmail = `-- name: VerifyUserEmail :one
UPDATE users
SET email_verified = TRUE,
    email_verification_token_hash = NULL,
    email_verification_expires_at = NULL
WHERE id = $1
RETURNING id, email, email_verified, name, picture, password_hash, provider, google_id, email_verification_token_hash, email_verification_expires_at, failed_login_attempts, locked_until, created_at, updated_at
`

func (q *Queries) VerifyUserEmail(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, verifyUserEmail, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
		&i.Picture,
		&i.PasswordHash,
		&i.Provider,
		&i.GoogleID,
		&i.EmailVerificationTokenHash,
		&i.EmailVerificationExpiresAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $2
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const upsertUserByGoogleID = `-- name: UpsertUserByGoogleID :one
INSERT INTO users (email, email_verified, name, picture, password_hash, provider, google_id)
VALUES ($1, $2, $3, $4, NULL, 'google', $5)
ON CONFLICT (google_id) DO UPDATE
SET email = EXCLUDED.email,
    email_verified = EXCLUDED.email_verified,
    name = EXCLUDED.name,
    picture = EXCLUDED.picture,
    provider = 'google'
RETURNING id, email, email_verified, name, picture, password_hash, provider, google_id, email_verification_token_hash, email_verification_expires_at, failed_login_attempts, locked_until, created_at, updated_at
`

type UpsertUserByGoogleIDParams struct {
	Email         string      `json:"email"`
	EmailVerified bool        `json:"email_verified"`
	Name          string      `json:"name"`
	Picture       pgtype.Text `json:"picture"`
	GoogleID      pgtype.Text `json:"google_id"`
}

func (q *Queries) UpsertUserByGoogleID(ctx context.Context, arg UpsertUserByGoogleIDParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUserByGoogleID,
		arg.Email,
		arg.EmailVerified,
		arg.Name,
		arg.Picture,
		arg.GoogleID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
		&i.Picture,
		&i.PasswordHash,
		&i.Provider,
		&i.GoogleID,
		&i.EmailVerificationTokenHash,
		&i.EmailVerificationExpiresAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
